package main

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"testing"
)

func Test_solvePart1(t *testing.T) {
	tests := []struct {
		field       string
		wantX       int
		wantY       int
		wantMaxSeen int
	}{
		{
			".#..#..###\n" +
				"####.###.#\n" +
				"....###.#.\n" +
				"..###.##.#\n" +
				"##.##.#.#.\n" +
				"....###..#\n" +
				"..#.#..#.#\n" +
				"#..#.#.###\n" +
				".##...##.#\n" +
				".....#.#..", 6, 3, 41,
		},
		{
			".#..##.###...#######\n" +
				"##.############..##.\n" +
				".#.######.########.#\n" +
				".###.#######.####.#.\n" +
				"#####.##.#.##.###.##\n" +
				"..#####..#.#########\n" +
				"####################\n" +
				"#.####....###.#.#.##\n" +
				"##.#################\n" +
				"#####.##.###..####..\n" +
				"..######..##.#######\n" +
				"####.##.####...##..#\n" +
				".#####..#.######.###\n" +
				"##...#.##########...\n" +
				"#.##########.#######\n" +
				".####.#.###.###.#.##\n" +
				"....##.##.###..#####\n" +
				".#.#.###########.###\n" +
				"#.#.#.#####.####.###\n" +
				"###.##.####.##.#..##", 11, 13, 210,
		},
		{
			"......#.#.\n" +
				"#..#.#....\n" +
				"..#######.\n" +
				".#.#.###..\n" +
				".#..#.....\n" +
				"..#....#.#\n" +
				"#..#....#.\n" +
				".##.#..###\n" +
				"##...#..#.\n" +
				".#....####", 5, 8, 33,
		},
		{
			"#.#...#.#.\n" +
				".###....#.\n" +
				".#....#...\n" +
				"##.#.#.#.#\n" +
				"....#.#.#.\n" +
				".##..###.#\n" +
				"..#...##..\n" +
				"..##....##\n" +
				"......#...\n" +
				".####.###.", 1, 2, 35,
		},
		{
			".#..#\n" +
				".....\n" +
				"#####\n" +
				"....#\n" +
				"...##", 3, 4, 8,
		},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("part1_%d", i), func(t *testing.T) {
			fld := parseField(tt.field)
			visible := countVisible(fld, Point{X: tt.wantX, Y: tt.wantY})
			if visible != tt.wantMaxSeen {
				t.Errorf("solvePart1() countVisible = %v, want %v", visible, tt.wantMaxSeen)
			}
			gotX, gotY, gotMaxSeen := solvePart1(fld)
			if gotX != tt.wantX {
				t.Errorf("solvePart1() gotX = %v, want %v", gotX, tt.wantX)
			}
			if gotY != tt.wantY {
				t.Errorf("solvePart1() gotY = %v, want %v", gotY, tt.wantY)
			}
			if gotMaxSeen != tt.wantMaxSeen {
				t.Errorf("solvePart1() gotMaxSeen = %v, want %v", gotMaxSeen, tt.wantMaxSeen)
			}
		})
	}
}

func Test_solvePart2(t *testing.T) {
	field := "" +
		".#..##.###...#######\n" +
		"##.############..##.\n" +
		".#.######.########.#\n" +
		".###.#######.####.#.\n" +
		"#####.##.#.##.###.##\n" +
		"..#####..#.#########\n" +
		"####################\n" +
		"#.####....###.#.#.##\n" +
		"##.#################\n" +
		"#####.##.###..####..\n" +
		"..######..##.#######\n" +
		"####.##.####...##..#\n" +
		".#####..#.######.###\n" +
		"##...#.##########...\n" +
		"#.##########.#######\n" +
		".####.#.###.###.#.##\n" +
		"....##.##.###..#####\n" +
		".#.#.###########.###\n" +
		"#.#.#.#####.####.###\n" +
		"###.##.####.##.#..##"
	base := Point{X: 11, Y: 13}
	x, y := solvePart2(parseField(field), base)
	assert.Equal(t, 8, x)
	assert.Equal(t, 2, y)
}
